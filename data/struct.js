
// Derived from the awesome work from Eike Decker and their cpp-struct-js library, originally intended for NodeJS https://github.com/zet23t/cpp-struct-js
// Modified to work in a browser, with a DataView and object definition

function struct(name, schema, count, bytes) {
  this.name = name
  this.schema = schema
  this.bytes = bytes || 0

  for (var [name, type] of Object.entries(schema)) {
    if (!(type instanceof struct)) {
      schema[name] = new struct(name + "_t", type)
      type = schema[name]
    }
    this.bytes += type.size();
  }

  this.count = count || 1
  this.encoder = struct.encoder
  this.decoder = struct.decoder
};

// instance members  
struct.prototype.setEncoder = function (f) {
  this.encoder = f
  return this
}

struct.prototype.setDecoder = function (f) {
  this.decoder = f
  return this
}

struct.prototype.setIsNoArray = function (noArray) {
  this.isNoArray = noArray
  return this
}

struct.prototype.forEachInSchema = function (f) {
  for (var [name, type] of Object.entries(this.schema)) {
    f(name, type)
  }
}

struct.prototype.size = function () {
  return this.bytes * this.count
}

struct.prototype.toString = function () {
  var out = ['struct ' + this.name + ' {']
  this.forEachInSchema((name, type) => {
    var arr = type.count > 1 ? '[' + type.count + ']' : ''
    out.push('  ' + type.name + ' ' + name + arr + '; // Size: ' + type.size())
  })
  out.push('}; // Size: ' + this.size())
  return out.join('\n')
}

struct.prototype.encode = function (buffer, pos, data, opt) {
  this.encoder(buffer, pos || 0, data, opt)
}

struct.prototype.decode = function (buffer, pos, opt) {
  return this.decoder(buffer, pos || 0, opt)
}

// class members
struct.encoder = function (buffer, pos, data, opt) {
  this.forEachInSchema((name, type) => {
    var dval = data && data[name]
    // console.log(pos,this.name+"."+name,type.name,type.size(),type.schema)
    for (var j = 0; j < type.count; j += 1) {
      var el = dval && dval.join ? dval[j] : dval
      type.encode(buffer, pos, el, opt)
      if (type.isNoArray) {
        pos += type.size()
        break
      } else {
        pos += type.bytes
      }
    }
  })
}

struct.decoder = function (buffer, pos, opt) {
  var data = {}
  this.forEachInSchema((name, type) => {
    if (type.count === 1 || type.isNoArray) {
      data[name] = type.decode(buffer, pos, opt)
      pos += type.size()
    } else {
      var arr = []
      data[name] = arr
      for (var i = 0; i < type.count; i += 1) {
        arr[i] = type.decode(buffer, pos, opt)
        // console.log(pos,arr[i],type)
        pos += type.bytes
      }
    }
  })
  return data
}

struct.type = function (type, size, count) {
  if (type.size && count === undefined) {
    count = size
    size = type.size()
  }
  return new struct(type.name || type, [], count, size)
    .setEncoder(
      (buffer, pos, data, opt) => {
        type.encode(buffer, pos, data, opt)
      }
    )
    .setDecoder(
      (buffer, pos, opt) => {
        return type.decode(buffer, pos, opt)
      }
    )
}
struct.char = function (n) {
  return this.type('char', 1, n)
    .setIsNoArray(true)
    .setEncoder(
      (buffer, pos, data, opt) => {
        var str = data ? data.toString() : ''
        for (var i = 0; i < n; i += 1) {
          buffer.setUint8(i < str.length ? str[i] : '\0', pos + i)
        }
      }
    )
    .setDecoder(
      (buffer, pos, opt) => {
        var text = '';
        var val = -1;
        for (var i = 0; i < n; i++) {
          if (pos + i > buffer.byteLength) break;

          val = buffer.getUint8(pos + i);
          if (val == 0) break;

          text += String.fromCharCode(val);
        }
        return text
      }
    )
}

struct.toHeaderString = function (list) {
  const d = new Date()
  const date = d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate() + ' ' + d.getHours() + ':' + d.getMinutes()
  const out = ['// AUTOGENERATED CODE BY cpp-struct.js @ ' + date]
  for (let i = 0; i < list.length; i += 1) {
    out.push('struct ' + list[i].name + ';')
  }
  out.push('')
  for (let i = 0; i < list.length; i += 1) {
    out.push(list[i].toString())
    out.push('')
  }
  out.push('// check if sizes are as expected - if the compiler errors here')
  out.push('// with a negative array size complaint, it means that the javascript')
  out.push('// struct definitions are not matching the memory alignment of your')
  out.push('// compiler. Insert placeholder elements to match the sizes.')
  out.push("// Don't deactivate the tests! As long as the sizes differ, ")
  out.push('// encoding and decoding will give wrong results!')
  out.push('')
  for (var i = 0; i < list.length; i += 1) {
    var s = list[i]
    out.push('typedef char _CheckSizeOf' + s.name +
      '_[sizeof(' + s.name + ') == ' + s.size() + ' ? 1 : -1];')
  }
  return out.join('\n')
}

function addNumberType(jsName, bytes, alias, aliasCPP) {

  var writeName = 'write' + jsName
  var readName = 'read' + jsName
  var writeAccess = "set" + jsName
  var readAccess = "get" + jsName

  if (!alias) alias = jsName.toLowerCase()
  struct[alias] = function (n) {
    return this.type(aliasCPP || (jsName.toLowerCase() + '_t'), bytes, n)
      .setEncoder(
        (buffer, pos, data, opt) => {
          buffer[writeAccess](pos, data || 0, isLittleEndian(opt))
        }
      )
      .setDecoder(
        (buffer, pos, opt) => {
          return buffer[readAccess](pos, isLittleEndian(opt))
        }
      )
  }
}

addNumberType('Uint8', 1)
addNumberType('Uint16', 2)
addNumberType('Uint32', 4)
addNumberType('BigUint64', 8)
addNumberType('Int8', 1)
addNumberType('Int16', 2)
addNumberType('Int32', 4)
addNumberType('BigInt64', 8)
addNumberType('Float32', 4)
addNumberType('Float64', 8)

struct.boolean = function (n) {
  return this.type('bool', 1, n)
    .setIsNoArray(true)
    .setEncoder(
      (buffer, pos, data, opt) => {
        buffer.setUint8(pos, data ? 1 : 0 );
      }
    )
    .setDecoder(
      (buffer, pos, opt) => {
        var val = buffer.getUint8(pos);
        
        return val > 0;
      }
    )
}

struct.ipAddress = function (n) {
  return this.type('IPAddress', 8, n)
    .setIsNoArray(true)
    .setEncoder(
      (buffer, pos, data, opt) => {
        // TODO
      }
    )
    .setDecoder(
      (buffer, pos, opt) => {
        var junk = buffer.getUint32(pos);
        var octet1 = buffer.getUint8(pos + 4);
        var octet2 = buffer.getUint8(pos + 5);
        var octet3 = buffer.getUint8(pos + 6);
        var octet4 = buffer.getUint8(pos + 7);

        return `${octet1}.${octet2}.${octet3}.${octet4}`;
      }
    )
}

struct.map8 = function (map, n) {
  return this.type('Uint8', 1, n)
    .setIsNoArray(true)
    .setEncoder(
      (buffer, pos, data, opt) => {
        // TODO
      }
    )
    .setDecoder(
      (buffer, pos, opt) => {
        var byte = buffer.getUint8(pos);
        var bit = 0;
        var out = {};

        for (var [name, size] of Object.entries(map)) {
          var val = 0;
          for(var s = 0; s < size; s++){
            val = val << 1;
            val |= (byte & (1 << bit)) === 0 ? 0 : 1;
            bit++;
          }
          out[name] = val;
        }

        return out;
      }
    )
}

function isLittleEndian(opt) {
  return opt && opt.endian === 'LE' ? 1 : 0
}
